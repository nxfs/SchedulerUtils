# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
from collections import defaultdict

import math
import os
import sys

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
	'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *


class Topo:
    def __init__(self):
        self.cores = {}
        self.cpus = {}
        self.cpus_per_core = None

    def add_cpu(self, cpu):
        self.cpus[cpu.id] = cpu
        if cpu.core_id not in self.cores:
            self.cores[cpu.core_id] = Core(cpu.core_id)
        self.cores[cpu.core_id].add_cpu(cpu.id)


class Cpu:
    def __init__(self, id, core_id):
        self.id = id
        self.core_id = core_id


class Core:
    def __init__(self, id):
        self.id = id
        self.cpu_ids = []

    def add_cpu(self, cpu_id):
        self.cpu_ids.append(cpu_id)


def parse_topo(file):
    topo = Topo()
    with open(file, 'r') as file:
        for line in file:
            line = line.strip()
            if line.startswith('processor'):
                cpu_id = int(line.split(':')[1].strip())
            elif line.startswith('core id'):
                core_id = int(line.split(':')[1].strip())
                cpu = Cpu(cpu_id, core_id)
                topo.add_cpu(cpu)
    cpus_per_core = None
    for core_id, core in topo.cores.items():
        if cpus_per_core is None:
            cpus_per_core = len(core.cpu_ids)
        else:
            assert len(core.cpu_ids) == cpus_per_core
    topo.cpus_per_core = cpus_per_core
    return topo

class CpuEvent:
    def __init__(self, ts, cookie):
        self.ts = ts
        self.cookie = cookie

class CpuTimeline:
    def __init__(self):
        self.cpu_events = []

    def add_cpu_event(self, ce):
        self.cpu_events.append(ce)

class CookieEvent:
    def __init__(self, ts, pid, cpu):
        self.ts = ts
        self.pid = pid
        self.cpu = cpu

class CookieTimeline:
    def __init__(self):
        self.cookie_events = []

    def add_cookie_event(self, ce):
        self.cookie_events.append(ce)

class TaskState:
    def __init__(self):
        self.cookie = 0

class HostTimeline:
    def __init__(self):
        self.events = []
        self.cpu_timeline = defaultdict(CpuTimeline)
        self.cookie_timeline = defaultdict(CookieTimeline)
        self.task_states = defaultdict(TaskState)

    def add_runtime_event(self, cpu, pid, start, runtime):
        cookie = self.task_states[pid].cookie

        ce = CpuEvent(start, cookie)
        self.cpu_timeline[cpu].add_cpu_event(ce)
        ce = CpuEvent(start + runtime, None)
        self.cpu_timeline[cpu].add_cpu_event(ce)

        ce = CookieEvent(start, pid, cpu)
        self.cookie_timeline[cookie].add_cookie_event(ce)
        ce = CookieEvent(start + runtime, pid, None)
        self.cookie_timeline[cookie].add_cookie_event(ce)

    def add_cookie_event(self, pid, cookie):
        self.task_states[pid].cookie = cookie

    def add_fork_event(self, parent_pid, child_pid):
        self.task_states[child_pid].cookie = self.task_states[parent_pid].cookie

def check_overlaps(ht, topo, debug_core=-1):
    class Overlap:
        def __init__(self):
            self.t = 0
            self.max = 0

    overlaps = {}
    for core in topo.cores.values():
        event_idxs = {}
        for cpu_id in core.cpu_ids:
            if len(ht.cpu_timeline[cpu_id].cpu_events) > 0:
                event_idxs[cpu_id] = 0
        active_cookies = {}
        overlap = Overlap()
        last_ts = None
        while len(event_idxs) > 0:
            min_ts = None
            min_ts_event_idx = None
            min_ts_cpu_id = None
            # select next event among smt siblings
            for cpu_id, event_idx in event_idxs.items():
                event = ht.cpu_timeline[cpu_id].cpu_events[event_idx]
                if not min_ts or min_ts > event.ts:
                    min_ts = event.ts
                    min_ts_event_idx = event_idx
                    min_ts_cpu_id = cpu_id
            ts = min_ts
            ts_event_idx = min_ts_event_idx
            ts_cpu_id = min_ts_cpu_id
            ts_event = ht.cpu_timeline[ts_cpu_id].cpu_events[ts_event_idx]
            if len(active_cookies) > 1:
                duration = ts - last_ts
                overlap.t += duration
                if duration > overlap.max:
                    overlap.max = duration
                if debug_core == core.id:
                    print(f"{core.id}: overlap+={duration}, active_cookie={active_cookies}")
            if debug_core == core.id:
                print(f"{core.id}: {ts} cpu[{ts_cpu_id}] -> {ts_event.cookie}")
            if ts_event_idx > 0:
                prev_event = ht.cpu_timeline[ts_cpu_id].cpu_events[ts_event_idx - 1]
                prev_event_cookie = prev_event.cookie
                if prev_event_cookie is not None:
                    active_cookies[prev_event_cookie] -= 1
                    if active_cookies[prev_event_cookie] == 0:
                        del active_cookies[prev_event_cookie]
            ts_event_cookie = ts_event.cookie
            if ts_event_cookie is not None:
                if ts_event_cookie not in active_cookies:
                    active_cookies[ts_event_cookie] = 0
                active_cookies[ts_event_cookie] += 1
            if len(ht.cpu_timeline[ts_cpu_id].cpu_events) == ts_event_idx + 1:
                del event_idxs[ts_cpu_id]
            else:
                event_idxs[ts_cpu_id] += 1
            last_ts = ts
        overlaps[core.id] = overlap
    total_overlap = Overlap()
    for core_id, overlap in overlaps.items():
        print(f"{core_id}: overlap(t={overlap.t}, max={overlap.max})")
        total_overlap.t += overlap.t
        if total_overlap.max < overlap.max:
            total_overlap.max = overlap.max
    print(f"total_overlap(t={total_overlap.t}, max={total_overlap.max})")

def check_spread(ht, topo):
    class Spread:
        def __init__(self):
            self.t = 0
            self.max = 0

    spreads = {}
    for cookie, timeline in ht.cookie_timeline.items():
        pid_to_core_id = {}
        active_cores = {}
        last_ts = None
        spread = Spread()
        for event in timeline.cookie_events:
            ts = event.ts
            if last_ts is not None:
                active_pids = len(pid_to_core_id)
                min_cores = math.ceil(active_pids, topo.cpus_per_core)
                actual_cores = len(active_cores)
                if actual_cores > min_cores:
                    duration = ts - last_ts
                    spread.t += (actual_cores - min_cores) * duration
                    if duration > spread.max:
                        spread.max = duration
            pid = event.pid
            if pid in pid_to_core_id:
                prev_core_id = pid_to_core_id[pid]
                active_cores[prev_core_id] -= 1
                if active_cores[prev_core_id] == 0:
                    del active_cores[prev_core_id]
                del pid_to_core_id[pid]
            cpu_id = event.cpu
            if cpu_id is not None:
                core_id = topo.cpus[cpu_id].core_id
                if core_id not in active_cores:
                    active_cores[core_id] = 0
                active_cores[core_id] += 1
                pid_to_core_id[pid] = core_id
            spreads[cookie] = spread
    total_spread = Spread()
    for cookie, spread in spreads.items():
        print(f"{cookie}: spread(t={spread.t}, max={spread.max})")
        total_spread.t += spread.t
        if total_spread.max < spread.max:
            total_spread.max = spread.max
    print(f"total_spread(t={total_spread.t}, max={total_spread.max})")

ht = None
topo = None

def trace_begin():
    global topo
    global ht
    topo = parse_topo("topo.txt")
    ht = HostTimeline()

def trace_end():
    if topo.cpus_per_core == 1:
        print("no HT, nothing to do")
        return
    check_overlaps(ht, topo)
    check_spread(ht, topo)

def sched__sched_stat_runtime(event_name, context, common_cpu,
    common_secs, common_nsecs, common_pid, common_comm,
    common_callchain, comm, pid, runtime, vruntime):
    cpu = common_cpu
    pid = common_pid
    start = common_secs * 1000000000 + common_nsecs
    ht.add_runtime_event(cpu, pid, start, runtime)

def sched__sched_stat_iowait(event_name, context, common_cpu,
                             common_secs, common_nsecs, common_pid, common_comm,
                             common_callchain, comm, pid, delay, perf_sample_dict):
    pass

def sched__sched_stat_sleep(event_name, context, common_cpu,
                            common_secs, common_nsecs, common_pid, common_comm,
                            common_callchain, comm, pid, delay, perf_sample_dict):
    pass

def sched__sched_stat_wait(event_name, context, common_cpu,
                           common_secs, common_nsecs, common_pid, common_comm,
                           common_callchain, comm, pid, delay, perf_sample_dict):
    pass

def sched__sched_process_fork(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, parent_comm, parent_pid, child_comm, child_pid,
		perf_sample_dict):
    ht.add_fork_event(parent_pid, child_pid)

def sched__sched_migrate_task(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, comm, pid, prio, orig_cpu,
	dest_cpu, perf_sample_dict):
    pass

def sched__sched_switch(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, prev_comm, prev_pid, prev_prio, prev_state,
	next_comm, next_pid, next_prio, perf_sample_dict):
    pass

def sched__sched_wakeup_new(event_name, context, common_cpu,
    common_secs, common_nsecs, common_pid, common_comm,
    common_callchain, comm, pid, prio, target_cpu,
        perf_sample_dict):
    pass

def sched__sched_waking(event_name, context, common_cpu,
    common_secs, common_nsecs, common_pid, common_comm,
    common_callchain, comm, pid, prio, target_cpu,
    perf_sample_dict):
    pass

def sched__sched_setcookie(event_name, context, common_cpu,
    common_secs, common_nsecs, common_pid, common_comm,
    common_callchain, comm, pid, old_cookie, new_cookie,
    perf_sample_dict):
    ht.add_cookie_event(pid, new_cookie)


def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
    raise Exception(f'Unhandled event: {event_name}')
